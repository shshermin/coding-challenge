================================================================================
                    NEURA MOTION PLANNING CHALLENGE
                         CLASS DIAGRAM (TEXTUAL)
================================================================================

LEGEND:
  [I]    = Interface (Abstract Base Class)
  [C]    = Concrete Class
  [S]    = Static Utility Class
  [D]    = Data Structure / Struct
  -->    = Inheritance
  -->*   = Composition (has-a relationship)
  ...    = Dependency (uses)

================================================================================
                          HIERARCHY OVERVIEW
================================================================================

INVERSE KINEMATICS MODULE:
┌────────────────────────────────────────────────────────────────────────────┐
│ [I] IKStrategy                                                             │
│     virtual bool solveIK(const geometry_msgs::Pose&,                       │
│                         std::vector<double>&)                             │
│     virtual ~IKStrategy()                                                 │
└────────────────────────────────────────────────────────────────────────────┘
                              △
                              │
                              │ inherits
                              │
┌────────────────────────────────────────────────────────────────────────────┐
│ [C] JacobianIKSolver : public IKStrategy                                  │
│                                                                            │
│ MEMBERS:                                                                   │
│  - move_group: shared_ptr<MoveGroupInterface>                            │
│  - planning_group: string                                                │
│  - max_iterations: int (default: 100)                                    │
│  - tolerance: double (default: 0.001)                                    │
│  - damping_factor: double (default: 0.01)                                │
│  - step_size: double (default: 1.0)                                      │
│                                                                            │
│ METHODS:                                                                   │
│  + JacobianIKSolver(shared_ptr, string, int, double, double, double)    │
│  + solveIK(const Pose&, vector<double>&) : bool [override]              │
│  + setMaxIterations(int)                                                 │
│  + setTolerance(double)                                                  │
│  + setDampingFactor(double)                                              │
│  + setStepSize(double)                                                   │
│  - computeJacobian(vector<double>&, Eigen::MatrixXd&) : bool (private)  │
│  - dampedLeastSquares(Eigen::MatrixXd&, Eigen::VectorXd&,               │
│                       Eigen::VectorXd&) : void (private)                 │
└────────────────────────────────────────────────────────────────────────────┘


SAMPLING MODULE:
┌────────────────────────────────────────────────────────────────────────────┐
│ [I] SamplingStrategy                                                       │
│     virtual std::vector<CartMotionPlanningData>                           │
│       generateWaypoints(const CartMotionPlanningData&,                    │
│                        const CartMotionPlanningData&,                     │
│                        int)                                               │
│     virtual ~SamplingStrategy()                                           │
└────────────────────────────────────────────────────────────────────────────┘
                              △
                              │
                              │ inherits
                              │
┌────────────────────────────────────────────────────────────────────────────┐
│ [C] UniformSampler : public SamplingStrategy                              │
│                                                                            │
│ METHODS:                                                                   │
│  + UniformSampler()                                                      │
│  + generateWaypoints(const CartMotionPlanningData&,                      │
│                      const CartMotionPlanningData&, int)                  │
│       : std::vector<CartMotionPlanningData> [override]                   │
│                                                                            │
│ ALGORITHM:                                                                 │
│  - Linear interpolation for position                                      │
│  - SLERP (Spherical Linear Interpolation) for orientation                │
│  - Generates N equally spaced waypoints between start and end            │
└────────────────────────────────────────────────────────────────────────────┘


DATA STRUCTURES MODULE:
┌────────────────────────────────────────────────────────────────────────────┐
│ [D] CartMotionPlanningData                                                 │
│                                                                            │
│ MEMBERS:                                                                   │
│  - pose: geometry_msgs::Pose (private)                                    │
│  - time_from_start: ros::Duration (private)                              │
│  - header: std_msgs::Header (private)                                     │
│                                                                            │
│ METHODS:                                                                   │
│  + CartMotionPlanningData()                                              │
│  + CartMotionPlanningData(const Pose&, const double&,                   │
│                           const Header&)                                  │
│  + getData() const : CartMotionPlanningData                              │
│  + getPose() const : const Pose&                                         │
│  + getTimeFromStart() const : const ros::Duration&                       │
│  + getHeader() const : const Header&                                      │
└────────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────────┐
│ [D] TrajectoryData                                                         │
│                                                                            │
│ MEMBERS:                                                                   │
│  - joint_trajectory: trajectory_msgs::JointTrajectory (private)          │
│  - cart_trajectory: CartMotionPlanningData (private)                      │
│                                                                            │
│ METHODS:                                                                   │
│  + getJointTrajectory() : JointTrajectory&                               │
│  + getJointTrajectory() const : const JointTrajectory&                   │
│  + getCartTrajectory() : CartMotionPlanningData&                         │
│  + getCartTrajectory() const : const CartMotionPlanningData&             │
│  + setJointTrajectory(const JointTrajectory&)                            │
│  + setCartTrajectory(const CartMotionPlanningData&)                      │
└────────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────────┐
│ [D] PlanCriteria (Enumeration)                                             │
│                                                                            │
│ VALUES:                                                                    │
│  - LENGTH                                                                 │
│  - SUM_ABS_JOINTS                                                        │
│  - PLAN_TIME                                                              │
└────────────────────────────────────────────────────────────────────────────┘


PLANNING MODULE:
┌────────────────────────────────────────────────────────────────────────────┐
│ [C] CartMotionPlanner (Static Methods Only)                               │
│                                                                            │
│ METHODS:                                                                   │
│  + planNumericalCartesianPath(                                           │
│      const CartMotionPlanningData& waypoint_A,                           │
│      const CartMotionPlanningData& waypoint_B,                           │
│      int num_waypoints = 10,                                             │
│      bool checkCollisions = false,                                       │
│      shared_ptr<SamplingStrategy> sampler = nullptr,                     │
│      shared_ptr<IKStrategy> ik_solver = nullptr)                         │
│      : moveit_msgs::RobotTrajectory                                      │
│                                                                            │
│ ALGORITHM:                                                                 │
│  1. Generate Cartesian waypoints using SamplingStrategy                   │
│  2. Solve IK for each waypoint using IKStrategy                           │
│  3. Validate waypoints against joint limits and collisions               │
│  4. Check collision-free paths between consecutive waypoints             │
│  5. Build complete joint trajectory                                       │
│                                                                            │
│ DEPENDENCIES:                                                              │
│  -->* SamplingStrategy (uses)                                             │
│  -->* IKStrategy (uses)                                                   │
│  -->* CartMotionPlanningData (uses)                                       │
└────────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────────┐
│ [C] MotionPlanning                                                         │
│                                                                            │
│ MEMBERS:                                                                   │
│  - node_handle: ros::NodeHandle&                                         │
│  - [other internal MoveIt interfaces]                                     │
│                                                                            │
│ METHODS:                                                                   │
│  + MotionPlanning(ros::NodeHandle&)                                      │
│  + planJoint(const vector<double>&,                                      │
│              RobotTrajectoryPtr&,                                         │
│              const string& = "") : bool                                   │
│  + planCartesian(const PoseStamped&,                                     │
│                  RobotTrajectoryPtr&,                                     │
│                  const string& = "RRTConnect",                            │
│                  double = 10.0) : bool                                    │
│  + planNumericalCartesianPath(const CartMotionPlanningData&,             │
│                               const CartMotionPlanningData&,             │
│                               RobotTrajectoryPtr&,                        │
│                               int = 10,                                   │
│                               bool = false) : bool                        │
│                                                                            │
│ DEPENDENCIES:                                                              │
│  -->* MoveGroupInterface (composition)                                     │
│  -->* PlanningSceneInterface (composition)                                │
│  -->* CartMotionPlanningData (uses)                                       │
│  -->* TrajectoryData (composition)                                        │
│  -->* CartMotionPlanner (uses)                                            │
└────────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────────┐
│ [C] PlanMetadata                                                           │
│                                                                            │
│ MEMBERS:                                                                   │
│  - length_: double (private)                                              │
│  - trajectory_file_: string (private)                                     │
│  - plan_time_: double (private)                                           │
│  - sum_abs_joints_: double (private)                                      │
│  - planner_id_: string (private)                                          │
│                                                                            │
│ METHODS:                                                                   │
│  + PlanMetadata()                                                        │
│  + PlanMetadata(const string& file, double plan_time)                    │
│  + PlanMetadata(const string& file, double plan_time,                    │
│                 const string& planner_id)                                │
│  + setTrajectoryFile(const string&)                                      │
│  + setPlanTime(double)                                                   │
│  + setPlannerId(const string&)                                           │
│  + getLength() const : double                                             │
│  + getTrajectoryFile() const : string                                    │
│  + getPlanTime() const : double                                          │
│  + getSumAbsJoints() const : double                                      │
│  + getPlannerId() const : string                                         │
│  + calculateLength(const JointTrajectory&)                               │
│  + calculateSumAbsJoints(const JointTrajectory&)                         │
│  + getCriteriaValue(PlanCriteria) const : double                         │
│                                                                            │
│ DEPENDENCIES:                                                              │
│  -->* PlanCriteria (uses)                                                 │
│  -->* JointTrajectory (uses)                                              │
└────────────────────────────────────────────────────────────────────────────┘


TRAJECTORY MODULE:
┌────────────────────────────────────────────────────────────────────────────┐
│ [S] TrajectoryVisualizer (Static Utility Class)                           │
│                                                                            │
│ METHODS:                                                                   │
│  + publishTrajectoryToRViz(const MoveGroupInterface::Plan&,              │
│                            ros::Publisher&) : void                        │
│  + logTrajectoryDetails(const JointTrajectory&) : void                    │
│                                                                            │
│ NOTE: All constructors deleted to enforce static-only usage              │
└────────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────────┐
│ [S] TrajectoryIO (Static Utility Class)                                    │
│                                                                            │
│ METHODS:                                                                   │
│  + writeVectorToStream(ostream&, const vector<double>&) : void           │
│  + writeJointTrajectory(ostream&,                                        │
│                         const JointTrajectory&) : void                    │
│  + writeCartesianPoses(ostream&,                                         │
│                        const vector<CartMotionPlanningData>&) : void      │
│                                                                            │
│ NOTE: All constructors deleted to enforce static-only usage              │
└────────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────────┐
│ [S] TrajectoryParser (Static Utility Class)                                │
│                                                                            │
│ METHODS:                                                                   │
│  + parseJointNames(const string&,                                        │
│                    vector<string>&) : void                                │
│  + parseWaypoint(ifstream&, string&,                                     │
│                  JointTrajectory&) : void                                 │
│  + parseVector(const string&) : vector<double>                           │
│  + parseJsonTrajectory(const string&,                                    │
│                        JointTrajectory&) : bool                           │
│                                                                            │
│ NOTE: All constructors deleted to enforce static-only usage              │
└────────────────────────────────────────────────────────────────────────────┘


UTILITY MODULE:
┌────────────────────────────────────────────────────────────────────────────┐
│ [S] TrajectoryValidatorAndOptimizer (Static Utility Class)                │
│                                                                            │
│ METHODS:                                                                   │
│  + validateTrajectory(                                                    │
│      const JointTrajectory&,                                              │
│      const string& group_name,                                            │
│      const PlanningScenePtr& = nullptr,                                  │
│      string* error_out = nullptr,                                         │
│      const RobotModelConstPtr& = nullptr) : bool                         │
│                                                                            │
│  + computeVelocity(const vector<double>&,                                │
│                    const vector<double>&,                                │
│                    double) : double                                       │
│                                                                            │
│  + optimizeTrajectory(JointTrajectory&,                                  │
│                       const string& = "arm",                              │
│                       bool = false,                                       │
│                       bool = false,                                       │
│                       const RobotModelConstPtr& = nullptr) : bool         │
│                                                                            │
│  + generateTrajectoryComparisonPlot(                                     │
│      const JointTrajectory& original_traj,                               │
│      const JointTrajectory& optimized_traj,                              │
│      const string& output_dir,                                           │
│      double orig_duration, double opt_duration,                          │
│      double orig_peak_vel, double opt_peak_vel,                          │
│      double orig_avg_vel, double opt_avg_vel,                            │
│      double orig_path_length, double opt_path_length) : bool             │
└────────────────────────────────────────────────────────────────────────────┘

┌────────────────────────────────────────────────────────────────────────────┐
│ [S] PlanComparator (Static Utility Class)                                 │
│                                                                            │
│ METHODS:                                                                   │
│  + getBestPlan(const vector<PlanMetadata>&,                              │
│                PlanCriteria) : optional<PlanMetadata>                     │
│                                                                            │
│  + sortPlansByCriteria(const vector<PlanMetadata>&,                      │
│                        PlanCriteria) : vector<PlanMetadata>               │
│                                                                            │
│ DEPENDENCIES:                                                              │
│  -->* PlanMetadata (uses)                                                 │
│  -->* PlanCriteria (uses)                                                 │
└────────────────────────────────────────────────────────────────────────────┘


================================================================================
                         COMPOSITION & DEPENDENCY MAP
================================================================================

CLASS RELATIONSHIPS:

MotionPlanning [main orchestrator]
  |
  ├──-->* MoveGroupInterface (MoveIt)
  ├──-->* PlanningSceneInterface (MoveIt)
  ├──-->* CartMotionPlanningData
  ├──-->* TrajectoryData
  ├──-->* CartMotionPlanner (static methods)
  └──-->* PlanMetadata

CartMotionPlanner [static utility]
  |
  ├──-->* SamplingStrategy (default: UniformSampler)
  ├──-->* IKStrategy (default: JacobianIKSolver)
  └──-->* CartMotionPlanningData

CartMotionPlanningData [data structure]
  |
  ├──-->* geometry_msgs::Pose
  ├──-->* ros::Duration
  └──-->* std_msgs::Header

TrajectoryData [data structure]
  |
  ├──-->* trajectory_msgs::JointTrajectory
  └──-->* CartMotionPlanningData

JacobianIKSolver [concrete IK strategy]
  |
  ├──-->* moveit::planning_interface::MoveGroupInterface
  ├──-->* moveit::robot_state::RobotState
  └──-->* Eigen::Dense

UniformSampler [concrete sampling strategy]
  └──-->* CartMotionPlanningData

PlanMetadata [plan storage]
  |
  ├──-->* trajectory_msgs::JointTrajectory
  ├──-->* PlanCriteria
  └──-->* planning_scene::PlanningScene

Utility Classes:
  ├─ TrajectoryVisualizer -->* trajectory_msgs::JointTrajectory
  ├─ TrajectoryIO -->* trajectory_msgs::JointTrajectory
  ├─ TrajectoryParser -->* trajectory_msgs::JointTrajectory
  ├─ TrajectoryValidatorAndOptimizer -->* trajectory_msgs::JointTrajectory
  │                                    -->* planning_scene::PlanningScene
  └─ PlanComparator -->* PlanMetadata
                    -->* PlanCriteria


================================================================================
                            DESIGN PATTERNS USED
================================================================================

1. STRATEGY PATTERN:
   - IKStrategy (abstract) with JacobianIKSolver (concrete implementation)
   - SamplingStrategy (abstract) with UniformSampler (concrete implementation)
   - Allows switching algorithms at runtime

2. COMPOSITION PATTERN:
   - MotionPlanning uses CartMotionPlanningData
   - TrajectoryData composes JointTrajectory and CartMotionPlanningData
   - Ensures clean separation of concerns

3. STATIC UTILITY CLASS PATTERN:
   - TrajectoryVisualizer, TrajectoryIO, TrajectoryParser
   - TrajectoryValidatorAndOptimizer, PlanComparator
   - Deleted constructors enforce static-only usage

4. FACTORY PATTERN (implicit):
   - CartMotionPlanner provides static factory method with pluggable strategies

5. TEMPLATE METHOD PATTERN:
   - Base classes (IKStrategy, SamplingStrategy) define algorithm structure
   - Derived classes implement specific steps


================================================================================
                          MODULE ORGANIZATION
================================================================================

InverseKinematics/
  ├─ IKStrategy.h (interface)
  └─ JacobianIKSolver.h (concrete, numerical IK solver)

Sampling/
  ├─ SamplingStrategy.h (interface)
  └─ UniformSampler.h (concrete, linear interpolation)

DataStructure/
  ├─ CartMotionPlanningData.h (Cartesian waypoint with metadata)
  └─ PlanCriteria.h (enumeration for plan comparison)

Planning/
  ├─ CartMotionPlanner.h (static Cartesian path planner)
  ├─ MotionPlanning.h (main orchestrator class)
  └─ PlanMetadata.h (plan metrics storage)

Trajectory/
  ├─ TrajectoryData.h (joint + Cartesian trajectory holder)
  ├─ TrajectoryVisualizer.h (RViz visualization utility)
  ├─ TrajectoryIO.h (file I/O utility)
  └─ TrajectoryParser.h (trajectory parsing utility)

Utility/
  ├─ ValidatorAndOptimizer.h (trajectory validation & optimization)
  └─ PlanComparator.h (plan comparison & selection)


================================================================================
                        ALGORITHM FLOW OVERVIEW
================================================================================

CARTESIAN PATH PLANNING WORKFLOW:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  MotionPlanning::planCartesian()
         │
         ├─> Create CartMotionPlanningData for start/end poses
         │
         ├─> CartMotionPlanner::planNumericalCartesianPath()
         │    │
         │    ├─> SamplingStrategy::generateWaypoints()
         │    │    (Default: UniformSampler with linear + SLERP)
         │    │
         │    ├─> For each sampled waypoint:
         │    │    └─> IKStrategy::solveIK()
         │    │         (Default: JacobianIKSolver using damped least squares)
         │    │
         │    ├─> Validate trajectory against:
         │    │    ├─ Joint limits
         │    │    └─ Collision constraints
         │    │
         │    └─> Return moveit_msgs::RobotTrajectory
         │
         ├─> TrajectoryValidatorAndOptimizer::validateTrajectory()
         │    (Optional comprehensive validation)
         │
         ├─> TrajectoryValidatorAndOptimizer::optimizeTrajectory()
         │    (Optional time parameterization)
         │
         ├─> Store in TrajectoryData
         │
         └─> Return success


JACOBIAN IK SOLVER ALGORITHM:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Input: target_pose (desired end-effector Cartesian pose)
  Output: joint_solution (joint angles that achieve target_pose)

  1. Initialize: q = current_joint_configuration
  2. Loop (max iterations or until convergence):
     a. Compute Jacobian J at current q
     b. Compute forward kinematics: x_current = FK(q)
     c. Compute error: Δx = target_pose - x_current
     d. Solve: Δq = (J^T*J + λI)^-1 * J^T * Δx
        (Damped least squares pseudo-inverse)
     e. Update: q = q + step_size * Δq
     f. Check convergence: if ||Δx|| < tolerance, return true
  3. Return false if not converged


UNIFORM SAMPLING ALGORITHM:
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

  Input: start, end (CartMotionPlanningData), num_waypoints
  Output: vector of CartMotionPlanningData

  For i = 0 to num_waypoints-1:
    t = i / (num_waypoints - 1)  // Normalized parameter [0, 1]
    
    Position: p = start.position * (1-t) + end.position * t
              (linear interpolation in 3D)
    
    Orientation: q = SLERP(start.orientation, end.orientation, t)
                 (spherical linear interpolation for smooth rotation)
    
    Append CartMotionPlanningData(pose, time, header) to result


================================================================================
